"use server";

import type { Category } from "@prisma/client";

import { auth } from "@/auth";
import { prisma } from "../prisma";

async function checkAuth(userID: string): Promise<boolean> {
  const session = await auth();
  return session?.user?.id === userID || false;
}

export async function getMangaCategory(
  userId: string,
  mangaId: string
): Promise<string | "NONE"> {
  try {
    // Check authentication
    if (!(await checkAuth(userId))) return "NONE";

    // Quick query selecting only necessary data
    const result = await prisma.libraryManga.findFirst({
      where: {
        mangaId,
        library: { userId }, // Connect via user library
      },
      select: { category: true },
    });

    return result?.category || "NONE";
  } catch (error) {
    console.error("Error fetching manga category:", error);
    throw new Error("Failed to fetch manga category.");
  }
}

export async function updateMangaCategory(
  userId: string,
  mangaId: string,
  category: Category | "NONE",
  latestChapterId: string
): Promise<{ message: string; status: number }> {
  try {
    // Check authentication
    if (!(await checkAuth(userId))) {
      // CHANGED: Translated error message
      return { message: "Please login again!", status: 401 };
    }

    // Find or create user library using upsert to reduce queries
    const library = await prisma.library.upsert({
      where: { userId },
      update: {}, // No update needed if exists
      create: { userId }, // Create new if not exists
    });

    const libraryId = library.id;

    if (category === "NONE") {
      // Remove Manga from library if category is "NONE"
      const deleteResult = await prisma.libraryManga.deleteMany({
        where: { libraryId, mangaId },
      });

      return deleteResult.count
        ? { message: "Update successful!", status: 200 } // CHANGED: Translated success message
        : { message: "Manga does not exist in library.", status: 404 }; // CHANGED: Translated error message
    } else {
      // Find or create Manga
      await prisma.manga.upsert({
        where: { mangadexId: mangaId },
        update: { latestChapterId }, // Update if exists
        create: { mangadexId: mangaId, latestChapterId }, // Create new if not exists
      });

      // Add or update Manga in library
      const existingEntry = await prisma.libraryManga.findFirst({
        where: { libraryId, mangaId },
      });

      if (existingEntry) {
        // Update category if exists
        await prisma.libraryManga.update({
          where: { id: existingEntry.id },
          data: { category },
        });
      } else {
        // Create new if not exists
        await prisma.libraryManga.create({
          data: { libraryId, mangaId, category },
        });
      }

      // CHANGED: Translated success message
      return { message: "Update successful!", status: 200 };
    }
  } catch (error) {
    console.error("Error updating manga category:", error);
    // CHANGED: Translated error message
    return { message: "An error occurred, please try again later!", status: 500 };
  }
}

export async function getUserLibrary(userId: string): Promise<{
  FOLLOWING: string[];
  READING: string[];
  PLAN: string[];
  COMPLETED: string[];
}> {
  try {
    // Check authentication
    if (!(await checkAuth(userId))) {
      return { FOLLOWING: [], READING: [], PLAN: [], COMPLETED: [] };
    }

    // Find user library ID
    const library = await prisma.library.findUnique({
      where: { userId },
      select: { id: true },
    });

    if (!library)
      return { FOLLOWING: [], READING: [], PLAN: [], COMPLETED: [] };

    // Get all Manga in library and categorize
    const libraryMangas = await prisma.libraryManga.findMany({
      where: { libraryId: library.id },
      select: { mangaId: true, category: true },
    });

    // Use reduce to categorize Manga
    const result = libraryMangas.reduce(
      (acc: { [key in Category]: string[] }, { mangaId, category }) => {
        acc[category].push(mangaId);
        return acc;
      },
      { FOLLOWING: [], READING: [], PLAN: [], COMPLETED: [] } as {
        [key in Category]: string[];
      }
    );

    return result;
  } catch (error) {
    console.error("Error fetching user library:", error);
    throw new Error("Failed to fetch user library.");
  }
}
